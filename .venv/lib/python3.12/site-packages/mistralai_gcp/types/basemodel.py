"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from pydantic import ConfigDict, model_serializer
from pydantic import BaseModel as PydanticBaseModel
from pydantic_core import core_schema
from typing import TYPE_CHECKING, Any, Literal, Optional, TypeVar, Union
from typing_extensions import TypeAliasType, TypeAlias


class BaseModel(PydanticBaseModel):
    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, protected_namespaces=()
    )


class Unset(BaseModel):
    @model_serializer(mode="plain")
    def serialize_model(self):
        return UNSET_SENTINEL

    def __bool__(self) -> Literal[False]:
        return False


UNSET = Unset()
UNSET_SENTINEL = "~?~unset~?~sentinel~?~"


T = TypeVar("T")
if TYPE_CHECKING:
    Nullable: TypeAlias = Union[T, None]
    OptionalNullable: TypeAlias = Union[Optional[Nullable[T]], Unset]
else:
    Nullable = TypeAliasType("Nullable", Union[T, None], type_params=(T,))
    OptionalNullable = TypeAliasType(
        "OptionalNullable", Union[Optional[Nullable[T]], Unset], type_params=(T,)
    )


class UnrecognizedStr(str):
    @classmethod
    def __get_pydantic_core_schema__(cls, _source_type: Any, _handler: Any) -> core_schema.CoreSchema:
        # Make UnrecognizedStr only work in lax mode, not strict mode
        # This makes it a "fallback" option when more specific types (like Literals) don't match
        def validate_lax(v: Any) -> 'UnrecognizedStr':
            if isinstance(v, cls):
                return v
            return cls(str(v))

        # Use lax_or_strict_schema where strict always fails
        # This forces Pydantic to prefer other union members in strict mode
        # and only fall back to UnrecognizedStr in lax mode
        return core_schema.lax_or_strict_schema(
            lax_schema=core_schema.chain_schema([
                core_schema.str_schema(),
                core_schema.no_info_plain_validator_function(validate_lax)
            ]),
            strict_schema=core_schema.none_schema(),  # Always fails in strict mode
        )


class UnrecognizedInt(int):
    @classmethod
    def __get_pydantic_core_schema__(cls, _source_type: Any, _handler: Any) -> core_schema.CoreSchema:
        # Make UnrecognizedInt only work in lax mode, not strict mode
        # This makes it a "fallback" option when more specific types (like Literals) don't match
        def validate_lax(v: Any) -> 'UnrecognizedInt':
            if isinstance(v, cls):
                return v
            return cls(int(v))
        return core_schema.lax_or_strict_schema(
            lax_schema=core_schema.chain_schema([
                core_schema.int_schema(),
                core_schema.no_info_plain_validator_function(validate_lax)
            ]),
            strict_schema=core_schema.none_schema(),  # Always fails in strict mode
        )
